% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tuneLambda.R
\name{tuneLambda}
\alias{tuneLambda}
\title{Hyper parameter tuning of a penalty lambda parameter for LASSO and ridge regression. A 4-fold cross validation is performed with the received data.
For every fold, a model is trained on the 3 other folds with 100 probed lambda parameters to predict the values of the left-out fold.
Per fold, the AUC is calculated for normal weight versus obese patients for every probed lambda.
The AUC values are averaged over the 4 folds for each probed lambda.
The lambda with the highest AUC fold average is chosen}
\usage{
tuneLambda(
  data_matrix,
  alpha,
  new.y,
  effect,
  transformation,
  returnAll = FALSE
)
}
\arguments{
\item{data_matrix}{Measured metabolite values and possibly in matrix format}

\item{alpha}{A parameter passed to glmnet. Set to 0 for ridge regression and to 1 for LASSO regression}

\item{new.y}{A vector having the same length as the number of rows of data_matrix. It represents the log(BMI) values according the data in data_matrix}

\item{effect}{"main" or "interaction" dependent on which effects are wished in the model}

\item{transformation}{"Log" or "Inv", dependent on whether regression on log(BMI) or 1/BMI is required}

\item{returnAll}{Logical. If FALSE, return the tuned lambda parameter, if TRUE return all probed lambdas and probed AUCs as a data frame}
}
\value{
If returnAll=TRUE, returns a data frame with all probed lanmba values and the according AUC to distinguish normal weight and obese patients.
If returnAll=FALSE, returns a single numeric value for the best lambda
}
\description{
Hyper parameter tuning of a penalty lambda parameter for LASSO and ridge regression. A 4-fold cross validation is performed with the received data.
For every fold, a model is trained on the 3 other folds with 100 probed lambda parameters to predict the values of the left-out fold.
Per fold, the AUC is calculated for normal weight versus obese patients for every probed lambda.
The AUC values are averaged over the 4 folds for each probed lambda.
The lambda with the highest AUC fold average is chosen
}
\examples{

metabolites <- c("met1", "met2", "met_coll", "met_110")

df_oversample <- oversample(df)
AUCs <- tuneLambda(data_matrix=makeMatrix(df_oversample)$mat,
                   new.y = df_oversample$BMI, alpha=0,
                   effect="main", transformation="Log",
                   returnAll=TRUE)
bestLambda <- AUCs$lambda[which.max(AUCs$AUC)]
plot(AUC~log(lambda), AUCs)
abline(v=log(bestLambda), col="blue")

}
